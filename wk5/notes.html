<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" type="text/cs" href="styles/main.css">
    <title>JavaScript: Novice to Ninja, 2nd Edition</title>

    <style>
        textarea {
            width: 800px;
            height: 250px;
            background-color: #ffffe0;
        }
    </style>

</head>

<body>
    <header class="page_header"></header>
    <main>
        <section id="form_notes">
            <h1>Wk 5 Notes</h1><br>
            <h2>Testing & Debugging</h2>
            <h3>Errors, exceptions, and warnings</h3>
            <b>Errors</b> are caused by one of the following:
            1. System error ― there’s a problem with the system or external devices with which the program is interacting.
            2. Programmer error ― the program contains incorrect syntax or faulty logic; it could even be as simple as a typo.
            3. User error ― the user has entered data incorrectly, which the program is unable to handle.

            <h3>Exceptions</h3><br>
            An <b>exception</b> is an error that produces a return value that can then be used by the program to deal with the error.<br>
            Ex: Call the unicorn method<br>
            <code>
                unicorn();
                ReferenceError: unicorn is not defined
            </code><br>

            <h3>Stack Traces</h3><br>
            An exception will also produce a <b>stack</b> trace. This is a sequence of functions or method calls that lead to the point 
            where the error occurred. It’s often not just a single function or method call that causes an error. A stack trace 
            will work backwards from the point at which the error occurred to identify the original function or method that started 
            the sequence.<br>
            Ex: Locate the error using stack trace<br>
            <code>
            function three(){ unicorn(); }
            function two(){ three(); }
            function one(){ two(); }
            one();
            index.html:13 Uncaught ReferenceError: unicorn is not defined
            at three (index.html:13)<!--invoke the function two-->
            at two (index.html:17)<!--invoke the function three-->
            at one (index.html:21)<!--invoke the unicorn function that doesn't exist & causes the error-->
            at index.html:24`
            </code><br>

            <h3>Warnings</h3><br>
            A <b>warning</b> can occur if there’s an error in the code that isn't enough to cause the program to crash. This means the program 
            will continue to run after a warning. This might sound good, but it can be problematic.<br>
            Ex: Assigns a value to a var that's undeclared<br>
            <code>
                pi = 3.142;
                JavaScript Warning: assignment to undeclared variable
            </code><br>
            When a runtime error occurs in the browser, the HTML will still appear, but the JavaScript code will stop working in the background,
            which isn’t always obvious at first. If a warning occurs, the JavaScript will continue to run (although possibly incorrectly).<br>      
        </section>
        
            
        <section>
            <h3>The Importance of Testing & Debugging</h3><br>
            JavaScript is a fairly forgiving language when it comes to errors; it didn’t implement exceptions at all until ECMAScript version 3. 
            Instead of alerting a user to an error in a program, it just failed silently in the background.  Failing silently makes errors difficult 
            to spot and longer to track down. For this reason, a programmer should ensure that the code they write fails loudly in development so 
            any errors can be identified and fixed quickly in production. This is achieved by making sure exceptions are caught and dealt with, and 
            code is tested rigorously. 
        </section>

        <section>
            <h3>Strict Mode</h3><br>
            <b>Strict mode</b>  produces more exceptions and warnings and prohibits the use of some deprecated features.  Writing code in strict mode 
            can also help improve its clarity and speed, since it follows conventions and will throw exceptions if any sloppy code practices are used.
            Simply add th efollowing string to the first line of a JS file<br>
            Ex: Add strict mode to the JS file<br>
            <code>
                'use strict';
            </code>
            If strict mode dosn't exist in your JS engine it will produce an exception of ReferenceError : 3 is not defined. You can also use it on a 
            a per-function basis by adding the line inside a function like so.<br>
            Ex: Add strict mode to the line with your function.<br>
            <code>
                function strictly(){
                    'use strict';
                    // function code goes here
            </code><br>
            It's better practice to invokke strict mode on all of your code like so.<br>
            Ex: Add Strict mode at the beginning of your code to ensure the entire code is covered<br>
            <code>
                (function() {
                    'use strict';
                    // All your code would go inside this function
                }());
            </code><br>

            <h3>Linting Tools</h3><br>
            Linting tools such asJS Lint,JS Hint,andES Lintcan be used to test the quality of JavaScript code, beyond simply using strict mode. They are designed 
            to highlight any sloppy programming practices or syntax errors, and will complain if certain style conventions are not followed.  Linting tools are 
            also useful for enforcing a programmingstyle guide. This is particularly useful when you are working in a team. Here are some JS strict mode online 
            programs that will help grammatically correct your JS errors.<br>
            <div class="js_lint">Here's a complete reference<a href="http://jslint.com/">
                Sitepoint</a>
            </div>
            <div class="js_hint">Here's a complete reference<a href="https://jshint.com/">
                Sitepoint</a>
            </div>
            <div class="es_lint">Here's a complete reference<a href=" https://eslint.org/">
                Sitepoint</a>
            </div>
            <h3>Feature Dectection</h3><br>
            You can’t always rely on users having the most up-to-date browser. The recommended way to determine browser support for a feature is to use feature 
            detection. This is done using an if statement to check whether an object or method exists before trying to actually call the method.<br>
            Ex: Add the 'holoDeck' API method<br>
            <code>
                if (window.holoDeck) {
                    virtualReality.activate();
                }
            </code>
            This ensures that no error occurs if the browser doesn’t support the method, because referencing a nonexistent object such as window.virtualReality will 
            return undefined.  the if block won’t run, but calling the method virtualReality.activate() outside of the if block would cause an exception to be thrown. 
            Feature detection guarantees that the method is only called if it actually exists,  without any exceptions being thrown, if the method doesn't exist. 
            Modernizris a library that offers an easy way to implement feature detection andCan I Use?is another useful resource for checking which features are currently 
            supported in different browsers.<br>          
        </section>

        <section>
            <h3>Debugging in The Browser</h3><br>
            Debugging is the process of finding out where bugs occur in the code and then dealing with them. In many cases, the point at which an error occurs is not always 
            where it originated, so you’ll need to run through the program to see what’s happening at different stages of its execution. When doing this, it can be useful to 
            create what are known as breakpoints, which halt the progress of the code and allow us to view the value of different variables at that point in the program. 

            <h3> The Trusty Aleart</h3><br>
            The most basic form of debugging is to use the <b>alert()</b> method to show a dialog at certain points in the code. The <b>alert()</b> stops a program from running 
            until OK is clicked, it allows us to effectively put breakpoints in the code that let us check the value of variables at that point to see if they’re what we expect 
            them to be.<br>
            Ex: Validate if the age 12 is appropriate.
            <code>
                function amIOldEnough(age){
                    if (age = 12) {
                        alert(age);
                        return 'No, sorry.';
                    } else if (age < 18) {
                        return 'Only if you are accompanied by an adult.';
                    }
                    else {
                        return 'Yep, come on in!';
                    }
                }
                Once we click ok,we can then check the function returns the correct message.
                amIOldEnough(21)
                'No, sorry.'
                Passing an argument of 21 should result in the string 'Yep, come on in!' being returned, but it is returning 'No, sorry.' instead. If you tried running the example, 
                you would have seen the alert message show that the value of the variable age is 12 , even though the function was passed an argument of 21 . Closer inspection then 
                reveals a classic mistake has been made. Instead of checking if the value of age is equal to 12 , we have inadvertently assigned it the value of 12 ! To check for 
                equality, we should use === instead of = which assigns a value to a variable.
            </code><br>
            Ex: Validate if the age enter is less than 12 is old engouh.<br>
            <code>
                function amIOldEnough(age){
                    if (age < 12) {
                        alert(age);
                        return 'No, sorry.';
                    } else if (age < 18) {
                        return 'Only if you are accompanied by an adult.';
                    }
                    else {
                        return 'Yep, come on in!';
                    }
                }
                Now it will work as expected.<br>
                <code>
                    amIOldEnough(21)
                    'Yep, come on in!'
                </code>
                Now that JS has progressed, using trusty alert is discouraged.<br>
                
                <h3>Using the Console</h3><br>
                Most modern JavaScript environments have a <b>console</b> object that provides a number of methods for logging information and debugging. The <b>console.log()</b> method  
                can be used to log the value of variables at different stages of the program, although it will not actually stop the execution of the program in the same way as alert() does.<br>

                Ex: Log the position in the function as well as the value of the age variable.
                <code>
                    function amIOldEnough(age){
                        console.log(age);
                            if (age < 12) {
                            console.log(`In the if with ${age}`);
                            return 'No, sorry.';
                            } else if (age < 18) {
                            console.log(`In the else-if with ${age}`);
                            return 'Only if you are accompanied by an adult.';
                            } else {
                            console.log(`In the else with ${age}`);
                            return 'Yep, come on in!';
                        }
                    }
                </code>
                The <b>console.trace()</b> 
                method will log an interactive stack trace in the console. This will show the functions that were called in the lead up to an exception occurring while the code is running.<br>
                Here are some other methods of the console obj.
                <div class="console_api_methods">Here's a complete reference<a href="https://www.sitepoint.com/three-little-known-development-console-api-methods/"> Sitepoint</a>
                </div><br>

                <h3>Debugging Tools</h3><br>
                Most modern browsers also have a debugging tool that allows you to setbreakpointsin your code that will pause it at certain points. You can then see the values of all 
                the variables at those points and modify them. . Here are the links to the debugger documentation for each of the major browsers.<br>
                
                <div class="firefox">Here's a complete reference<a href="https://developer.mozilla.org/en-US/docs/Tools/Debugger">
                    Sitepoint</a>
                </div>

                <div class="ms_edge">Here's a complete reference<a href="https://docs.microsoft.com/en-us/microsoft-edge/devtools-guide/debugger">
                    Sitepoint</a>
                </div>

                <div class="chrome">Here's a complete reference<a href="https://developers.google.com/web/tools/chrome-devtools/?utm_campaign=2016q3&utm_medium=redirect&utm_source=dcc">
                    Sitepoint</a>
                </div>
            
                <div class="safari">Here's a complete reference<a href="https://developer.apple.com/library/archive/documentation/AppleApplications/Conceptual/Safari_Developer_Guide/Debugger/Debugger.html">
                    Sitepoint</a>
                </div>
                The <b>debugger</b> keyword  will create a breakpoint in your code that will pause the execution of the code and allow you to see where the program is currently up to. 
                You can also hover over any variables to see what value they hold at that point. The program can then be restarted by clicking on the 'play' button. If you try entering the code below into 
                your browser's console, then invoke the amIOldEnough() function, the browser's debugging tool will automatically kick in and you'll be able see the value of the age variable by hovering over it.
                Ex: Enter code into the broswer to see how it works<br>
                <code>
                    function amIOldEnough(age){
                        debugger;
                            if (age < 12) {
                            debugger;
                            return 'No, sorry.';
                            } else if (age < 18) {
                            debugger;
                            return 'Only if you are accompanied by an adult.';
                            } else {
                            debugger;
                            return 'Yep, come on in!';
                        }
                    }
                    amIOldEnough(16);
                </code>
                Remember to remove any references to the debugger command before shipping any code, otherwise the program will appear to freeze when people try to use it!
            </section>

        <section>
            <h3>Error Objects</h3><br>
            An <b>error</b> object can be created by the host environment when an exception occurs, or it can be created in the code using a constructor function.<br>
            Ex:Add an error obj to your code.
            Syntax:  const error = new Error();
            <code>
                const error = new Error('Oops, something went wrong');<br>
            </code>
            EvalError is not used in the current ECMAScript specification and only retained for backwards compatibility. It was used to identify errors when using the global eval() function.<br>
            RangeError is thrown when a number is outside an allowable range of values.<br>           
            ReferenceError is thrown when a reference is made to an item that doesn’t exist. For example, calling a function that hasn't been defined.<br>
            SyntaxError is thrown when there’s an error in the code’s syntax.<br>
            TypeError is thrown when there’s an error in the type of value used; for example, a string is used when a number is expected.<br>
            URIError is thrown when there’s a problem encoding or decoding the URI.<br>
            InternalError is a non-standard error that is thrown when an error occurs in the JavaScript engine. A common cause of this too much recursion.<br>
            Ex: Use one of the errors abv to create a custom erro Ojb.
            <code>
                const error = new TypeError('You need to use numbers in this function');<br>
            </code>
        
        </section>

        <section>
            <h3>Throwing exceptions</h3><br>
        </section>

        <section>
            <h3>Exception Handling</h3><br>
        </section>

        <section>
            <h3>Testing Frameworks</h3><br>
        </section>

        <div class="">Here's a complete reference<a href="">
            Sitepoint</a>
        </div>
        
        
    </main>
    <footer></footer>
    <script src="scripts/main.js"></script>
</body>

</html>