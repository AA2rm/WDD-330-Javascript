<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" type="text/cs" href="styles/main.css">
    <title>JavaScript: Novice to Ninja, Function Properties & Methods</title>

    <style>
        textarea {
            width: 800px;
            height: 250px;
            background-color: #ffffe0;
        }
    </style>
</head>

<body>
    <header class="page_header"></header>
    <main>
        <section id="keywords">
            <h2>Key words for team activity</h2><br>
            comment type(newComment, adding & removing comments, saved comments, store comments in an array) uses a key    
                list steps
            methods (renderCommentList, filterCommentsByName, event listeners)
            properties-lines 51-55    
            Create a class w/ a constructor
            form to gather input.
            button to store in an array
            display a list of comments
            adding new instances
            filter comments
            control comment entry        
        </section>


        <section id="funtions_notes">
            <h1>Wk 7 Notes</h1><br>
            <h2>Function properties and methods</h2>
            <b>Functions</b> can have <b>properties</b> and <b>methods</b>.
            The <b>call()</b> method can be used to set the value of <b>this</b> inside a function to an object that is provided as the first argument.
            Ex. in main.js (lines 1-4). If the function that’s called requires any parameters, these need to be provided as arguments after the first 
            argument, which is always the value of <b>this</b>.  f a function doesn’t refer to an object as this in its body, it can still be called 
            using the call() method, but you need provide null as its first argument. If a function doesn’t refer to an object as this in its body, it 
            can still be called using the call() method, but you need provide <b>null</b> as its first argument. You can use an <b>apply()</b> method in 
           same way execept the arguments of the function uses an array, Ex: main.js (lines 14-20). 
        </section><br>

        <section>
            <h2>Custom Properties</h2><br>
            There is nothing to stop you adding your own properties to functions in the same way that you can add properties to any object in JavaScript.
            There are several types of properties: square.dsecription- describes what it does. Ex. main.js (lines22-29) cache property-it provides result caching, ormemoization.
        </section><br>


        <section>
            <h2>Inmmediately Invoked Function Expressions</h2><br>
            An <b>immediately invoked function expression</b> is an anonymous function that, as the name suggests, is invoked as soon as it’s defined. 
            This is easily achieved by placing parentheses at the end of the function definition (remember we use parentheses to invoke a function). The 
            function also has to be made into an expression, which is done by placing the whole declaration inside parentheses, as in this example:
            Ex. main.js (lines 31-36). Placing any temporary var code that uses the temporary variable inside an IIFE will ensure it’s only available while 
            the IIFE is invoked, then it will disappear
        </section><br>

        <section>
            <h2>Initialize Code</h2>
            An IIFE can be used to set up any initialization code that there’ll be no need for again. Because the code is only run once, there’s no need to 
            create any reusable, named functions, and all the variables will also be temporary. An IIFE will be invoked once, and can set up any variables, 
            objects and event handlers  hen the page loads. Ex. main.js (lines 38-45), but BEST PRACTICE is to use a  a block. This is because variables have 
            block scope when const or let are used, whereas in previous versions of JavaScript, only functions maintained the scope of variables.  Ex. 
            main.js (lines 47-53)
        </section><br>

        <section>
            <h2>SAFE Use of Strict Mode</h2>
            To avoid having <b>strict mode</b> on all of your code, but to place on a portion of your code you can implement in IIFE. Ex. main.js (lines
            . This  ensures that only your code inside the IIFE is forced to use strict mode. The same can be done for creating self-containe Code Blocks Ex. 
            main.js (lines 61-71).     
        </section>

        <sedtion>
            <h2>Functions that Define Themselves & Rewrite Themselves</h2><br>
            A <b>function</b>  is able to not only call itself, but define itself, and even redefine itself. This is done by assigning an anonymous function 
            to a variable that has the same name as the function. f the function is also assigned to another variable, this variable will maintain the original 
            function definition and not be rewritten. This is because the original function is assigned to a variable, then within the function, a variable with 
            the same name as the function is assigned to a different function. Another way to rewrite a function is using an  init-time branching. This enables 
            the functions to work more effectively in the browser, and avoid checking for features every time they’re invoked. A <b>recursive function</b>  is 
            one that invokes itself until a certain condition is met. It’s a useful tool to use when iterative processes are involved.
        </sedtion>

        <section>
            <h2>Event-driven Asynchronous Programming</h2><br>
            Callbacks can be used to facilitate event-driven asynchronous programming. JavaScript is a single-threaded environment, which means only one piece of 
            code will ever be processed at a time. A  a callback can be created that’s invoked when the event happens. This means that the code is able to run out 
            of order, orasynchronously. Once the task has been completed, the callback will be invoked before returning to the rest of the program. 
        </section>

        <section>
            <h2> Promises</h2><br>
            Apromiserepresents the future result of an asynchronous operation. When created  it calls an asynchronous operation and is then said to bepending. It 
            remains in this state while the operation is taking place. At this stage, the promise is said to beunsettled. Once the operation has completed, the promise 
            is said to have beensettled. A settled promise can result in two different outcomes:

            Resolved ― the asynchronous operation was completed successfully.
            Rejected ― the asynchronous operation didn’t work as expected, wasn't successfully completed or resulted in an error.

            There are several phases of Promises
            Super promise allows is when you are in  a pending phase while you wait on the results of an operation. Once the promise is settled, you deal with the 
            results in an appropriate way Create a promise w/ a construtor function. Deal w/ a settled promise using a the then() method can be used to deal with the 
            outcome. Chaining multiple promises by chaining them w/ the <b>then()</b> method.
        </section>

        <section>
            <h2>Async Funtions</h2><br>
            These functions are preceded by the async keyword and allow you to write asynchronous code as if it was synchronous. This is achieved by using the await operator 
            before an asynchronous function. This will wrap the return value of the function in a promise that can then be assigned to a variable. The next line of code is not
            executed until the promise is resolved. Ex. main.js (lines 73-83).
        </section>

        <section>
            <h2>Generalized Functions</h2><br>
            Callbacks can be used to build more generalized functions. Instead of having lots of specific functions, one function can be written that accepts a callback. 
            Ex main.js (lines 86-115).
        </section>

        <section>
            <h2>Functions That Return Functions</h2><br>
            Ex. main.js (lines 117-131)
        </section>

        <section>
            <h2>Closures</h2><br>
            A variable is only available inside the block it was created inside if the const or let keywords were used. his also applies to the body of a function if the var 
            keyword is used for <b>function scopes</b>. Ex. main.js (lines 133-157) . The variable 'inside' is outside of the scope of the function, because the var 'inside' is only 
            active while the function is active. A <b>closure</b> is a reference to a variable that was created inside the scope of another function, but is then kept 
            alive and used in another part of the program. The key for a  principles in creating closures is that an 'inner' function, which is declared inside another function, has 
            full access to all of the variables declared inside the scope of the function in which it’s declared (the 'outer' function). 
        </section>
        
        <section>
            <h2>functions Returning Functions</h2><br>
            <b>Functions</b> declared from within another function have access to any variables declared in the outer function’s scope. Ex main.js (line 154).
        </section>

        <section>
            <h2>Generators</h2><br>
            These are special functions used to produce iterators that maintain the state of a value. To define a generator function, an asterisk symbol ( * ) is 
            placed after the function declaration. Ex. main.js (lines 162-). Calling a generator function doesn’t actually run any of the code in the function; it returns a Generator 
            object that can be used to create an iterator that implements a next() method that returns a value every time the next() method is called. Ex. main.js(lines 162-176).
        </section>
        
        <section>
            <h2> Introduction to functional programming</h2><br>
            The ability to pass functions as arguments, return them from other functions, and use anonymous functions and closures, are all fundamental elements of functional programming 
            that JavaScript excels at. Functional programming is a programming paradigm, meaning that it can be used to program in a variety of paradigms (and sometimes a mash-up of them!).<br>

            <b>Pure functions</b> A pure function is a function that adheres to the following rules:<br>

            1) The return value of a pure function should only depend on the values provided as arguments. It doesn't rely on values from somewhere else in the program.
            2) There are no side-effects. A pure function doesn't change any values or data elsewhere in the program. It only makes non-destructive data transformations and returns new values, 
               rather than altering any of the underlying data.
            3) Referential transparency. Given the same arguments, a pure function will always return the same result.<br>
            
            In order to follow these rules, any pure function must have:<br>            
            At least one argument; otherwise the return value must depend on something other than the arguments of the function, breaking the first rule
            A return value; otherwise there’s no point in the function (unless it has changed something else in the program – in which case, it’s broken the 'no side-effects' rule).
            Pure functions help to make functional programming code more concise and predictable than in other programming styles.<br>
            Ex. main.js (lines 179-189)
            Ex. How to NOT write a pure function
            <code>
                let number = 42;
                let result = 0;
                function impureAdd(x) { <!--this is an impure function-->
                    result = number + x;<!--the value number is defined outside of the function, which changes the value of result returning a different value, if the value of var number is different-->
                }
                impureAdd(10);
                result;
                52
            </code>


            <b>High-order functions</b>

        </section>

        <section>
            <h2>Currying</h2><br>
            <b>Currying</b> is a process that involves the partial application of functions. A function is said to be curried when not all arguments have been supplied to the function, 
            so it returns another function that retains the arguments already provided, and expects the remaining arguments that were omitted when the original function was called. A final 
            result is only returned once all the expected arguments have eventually been provided.

        </section>
        <div class="">Here's a complete reference<a href="">
            Sitepoint</a> 
            <div class="">Here's a complete reference<a href="">
                Sitepoint</a> 
  </main>
    <footer></footer>
    <script src="scripts/main.js"></script>
</body>

</html>