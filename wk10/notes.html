<!DOCTYPE html>
<html lang="en-us">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" type="text/cs" href="styles/main.css">
    <title>MDN: Client Side Form Validation & MDN: Useing Fetch </title>

    <style>
        /* Style the email portion of the page*/
        
    </style>
</head>

<body>
    <div id="portfolio_log">
        <div id="tag_line">
            <p style="color:#6600cc">Come Learn JavaScript With Me!</p>
        </div>
        <img src="images/lady.gif" title="Portfolio">
    </div>

    <header class="top_header_med_lavender"></header>
    <header class="top_header_violet"></header>
    <header class="page_header">
        <ul id="nav_bar">
            <li><a href="https://github.com/AA2rm/WDD-330-Javascript/" title="Git HubPage">repository</a></li>
            <li><a href="https://aa2rm.github.io/WDD-330-Javascript/" title="GitHub URL">master branch</a></li>
            <li><a href="#" title="User Feedback">feedback</a></li>
            <li>
                <!--<a href="#" title="Google">-->
                <form name='search' action='/search'><input name='searchInput'><button type='submit'>Search</button>
                </form>
                <!--</a>-->
            </li>
        </ul>
    </header>
    <header class="bottom_header_blue"></header>
    <main>
        <section id="form_validation">
            <h1>Chapter: Client-Side Form Validation </h1>(Pgs. )
            <ul>
                <li><a href="https://developer.mozilla.org/en-US/docs/Learn/Forms/Form_validation
                    " title="Form-Validation"> Client-Side Form Validation</a></li>
            </ul>
            <h2>Client-Side Form Validation</h2>
            Client-side validation is an initial check and an important feature of good user experience; by catching invalid data on the client-side, 
            the user can fix it straight away. The server can tell the client-side to tell the user to fix their data. Your apps should always perform 
            security checks on any form-submitted data on the server-side as well as the client-side, because client-side validation is too easy to bypass<br>

            <h2>What Is Form Validation?</h2>
            Form validation includes required fiels, phone # formats, valid email address, & passwords that are usally 8-30 charater long  that contain 1 
            uppercase leter, one symbol, & a number in it. browser and/or the web server will check to see that the data is in the correct format and within 
            the constraints set by the application. Validation done in the browser is called client-side validation, while validation done on the server is 
            called server-side validation. If correctly formatted the application allows the data to be submitted to the server and (usually) saved in a database; 
            if the information isn't correctly formatted, it gives the user an error message explaining what needs to be corrected. It's important in order to get
            the data to use the right format and protect the data.<br>

            <h2>Different Types Of client-Side Validation</h2>
            There are two different types of client-side validation.<br>
            * <b>Built-In validation</b> uses HTML5 form validation features<br>
            * <b>JavaScript validation</b> uses JS which can be create or you can use a library.<br>

            <h2>Using Built-IN Form Validation</h2>
            One of the most significant features of HTML5 form controls is the ability to validate most user data without relying on JavaScript. This is done by 
            using validation attributes on form elements.If the data entered in a form field follows all of the rules specified by the above attributes, it is 
            considered valid. If not, it is considered invalid. <br>
            * The element matches the :valid CSS pseudo-class, which lets you apply a specific style to valid elements.  the browser will submit the form, provided 
              there is nothing else stopping it from doing so (e.g., JavaScript).<br>
            * When an element is invalid, the following things are true: The element matches the :invalid CSS pseudo-class, and sometimes other UI pseudo-classes 
              (e.g., :out-of-range) depending on the error, which lets you apply a specific style to invalid elements. T the browser will block the form and display 
              an error message.<br>

            <b>required:</b> Specifies whether a form field needs to be filled in before the form can be submitted.
            <b>minlength and maxlength:</b> Specifies the minimum and maximum length of textual data (strings)
            <b>min and max:</b> Specifies the minimum and maximum values of numerical input types
            <b>type:</b> Specifies whether the data needs to be a number, an email address, or some other specific preset type. 
            <b>pattern:</b> Specifies a regular expression that defines a pattern the entered data needs to follow. <br>

            <b>Note:</b> There are several errors that will prevent the form from being submitted, including a badInput, patternMismatch, rangeOverflow or rangeUnderflow,
            stepMismatch, tooLong or tooShort, typeMismatch, valueMissing, or a customError. <br>

            <h2>Built-In Form Validation Exs</h2>
            Sample start file: see wk10/fruit-start.html<br>

            <h2>The Required Attribute</h2>
            When this attribute is set, the element matches the :required UI pseudo-class and the form won't submit, displaying an error message on submission when the input 
            is empty. While empty, the input will also be considered invalid, matching the :invalid UI pseudo-class.<br>

            <h2>Validating Against A Regular Expression</h2>
            A regular expression (regex) is a pattern that can be used to match character combinations in text strings, so regexs are ideal for form validation and serve a 
            variety of other uses in JavaScript. Below are some examples to give you a basic idea of how they work.<br>

            a — Matches one character that is a (not b, not aa, and so on).<br>
            abc — Matches a, followed by b, followed by c.<br>
            ab?c—Matches a, optionally followed by a single b, followed by c. ( ac or abc)<br>
            ab*c—Matches a, optionally followed by any number of bs, followed by c. ( ac , abc, abbbbbc, and so on).<br>
            a|b — Matches one character that is a or b.<br>
            abc|xyz — Matches exactly abc or exactly xyz (but not abcxyz or a or y, and so on).<br>

            For a complete list of <b>regular expression</b> follow the link below:
            <ul>
                <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions " title="Regular Expression"> Regular Expressopms</a></li>
            </ul>
            <b>Note:</b> Some <input> element types don't need a pattern attribute to be validated against a regular expression. Specifying the email type, for example, validates 
            the inputs value against a well-formed email address pattern or a pattern matching a comma-separated list of email addresses if it has the multiple attribute.<br>

            <b>Note:</b> The <u>textarea</u> element doesn't support the pattern attribute.<br>
            
            <h2>Constraining The Length Of Your Entries</h2>
            A field is invalid if it has a value and that value has fewer characters than the minlength value or more than the maxlength value. Constrain  constrain the character 
            length of all text fields created by <b>input</b> or <b>textarea</b> by using the <b>minlength</b> and <b>maxlength</b> attributes.<br>

            <h2>Constraining The Values Of Your Entries</h2>
            For number fields (i.e. <input type="number">), the min and max attributes can be used to provide a range of valid values. If the field contains a value outside this 
            range, it will be invalid.<br>
            <b>Note:</b> <input type="number"> (and other types, such as range and date) can also take a step attribute, which specifies what increment the value will go up or down 
            by when the input controls are used (such as the up and down number buttons). In the above example we've not included a step attribute, so the value defaults to 1. This 
            means that floats, like 3.2, will also show as invalid.<br>

            <h2>Full Example</h2>
            Note: see wk10/driver-lincense.html<br>

            <h2>Validating Forms Using JS</h2>
            You must use JavaScript if you want to take control over the look and feel of native error messages or to deal with legacy browsers that do not support HTML's built-in form 
            validation. In this section we will look at the different ways to do this.<br>

            <h2>The Constraint Validation API</h2>  
            Most browsers support the Constraint Validation API, which consists of a set of methods and properties available on the following form element <b>DOM interfaces:</b><br>

             
                * HTMLButtonElement (represents a button element)<br>
                * HTMLFieldSetElement (represents a fieldset element)<br>
                * HTMLInputElement (represents an input element)<br>
                * HTMLOutputElement (represents an output element)<br>
                * HTMLSelectElement (represents a select element)<br>
                * HTMLTextAreaElement (represents a textarea element)<br>

            
            The Constraint validation API makes the following <b>properties</b> available on the above elements.<br>

                * validationMessage: Returns a localized message describing the validation constraints that the control doesn't satisfy (if any). If the control is not a candidate for constraint 
                  validation (willValidate is false) or the element's value satisfies its constraints (is valid), this will return an empty string.<br>
                * validity: Returns a ValidityState object that contains several properties describing the validity state of the element. You can find full details of all the available properties 
                 in the ValidityState reference page; below is listed a few of the more common ones:<br>
                    ~ patternMismatch: Returns true if the value does not match the specified pattern, and false if it does match. If true, the element matches the :invalid CSS pseudo-class.<br>
                      tooLong: Returns true if the value is longer than the maximum length specified by the maxlength attribute, or false if it is shorter than or equal to the maximum. If true, the 
                      element matches the :invalid CSS pseudo-class.<br>
                    ~ tooShort: Returns true if the value is shorter than the minimum length specified by the minlength attribute, or false if it is greater than or equal to the minimum. If true, the 
                      element matches the :invalid CSS pseudo-class.<br>
                    ~ rangeOverflow: Returns true if the value is greater than the maximum specified by the max attribute, or false if it is less than or equal to the maximum. If true, the element 
                      matches the :invalid and :out-of-range CSS pseudo-classes.<br>
                    ~ rangeUnderflow: Returns true if the value is less than the minimum specified by the min attribute, or false if it is greater than or equal to the minimum. If true, the element 
                      matches the :invalid and :out-of-range CSS pseudo-classes.<br>
                    ~ typeMismatch: Returns true if the value is not in the required syntax (when type is email or url), or false if the syntax is correct. If true, the element matches the :invalid CSS 
                      pseudo-class.<br>
                    ~ valid: Returns true if the element meets all its validation constraints, and is therefore considered to be valid, or false if it fails any constraint. If true, the element matches 
                      the :valid CSS pseudo-class; the :invalid CSS pseudo-class otherwise.<br>
                    ~ valueMissing: Returns true if the element has a required attribute, but no value, or false otherwise. If true, the element matches the :invalid CSS pseudo-class.
            willValidate: Returns true if the element will be validated when the form is submitted; false otherwise.<br>

            The Constraint Validation API also makes the following methods available on the above elements. Customizing these error messages is one of the most common use cases of the constraint validation API.<br>

                *  checkValidity(): Returns true if the element's value has no validity problems; false otherwise. If the element is invalid, this method also fires an invalid event on the element.
                *  setCustomValidity(message): Adds a custom error message to the element; if you set a custom error message, the element is considered to be invalid, and the specified error is displayed. 
                   This lets you use JavaScript code to establish a validation failure other than those offered by the standard HTML5 validation constraints. The message is shown to the user when reporting 
                   the problem.<br>
            
            <h2>Implementing A Customized Error Message</h2>
            An error message is displayed depends on the browser.<br>

            These automated messages have two drawbacks:

                * There is no standard way to change their look and feel with CSS.<br>
                * They depend on the browser locale, which means that you can have a page in one language but an error message displayed in another language, as seen in the following Firefox screenshot.<br>


            <h2>A More Detailed Example</h2>
            When a form uses

            <h2>Validating Forms W/O A Built-In API</h2>
            the novalidate attribute to turn off the browser's automatic validation; this lets our script take control over validation. However, this doesn't disable support for the constraint validation API 
            nor the application of CSS pseudo-classes like :valid, etc. That means that even though the browser doesn't automatically check the validity of the form before sending its data, you can still do 
            it yourself and style the form accordingly. We are aiming to show the error messages inside a <b>span</b>> element. The aria-live attribute is set on that <b>span</b>> to make sure that our custom error message
            will be presented to everyone, including it being read out to screenreader users.<br>

            <b>Note:</b> A key point here is that setting the novalidate attribute on the form is what stops the form from showing its own error message bubbles, and allows us to instead display the custom error 
            messages in the DOM in some manner of our own choosing.<br>

            If the <b>input</b> to validate is an <input type="email">, it is required.

            The comments explain things pretty well, but briefly:

              * Every time we change the value of the input, we check to see if it contains valid data. If it has then we remove any error message being shown. If the data is not valid, we run showError() to show the appropriate 
                error.<br>
              * Every time we try to submit the form, we again check to see if the data is valid. If so, we let the form submit. If not, we run showError() to show the appropriate error, and stop the form submitting with
                preventDefault().<br>
              * The showError() function uses various properties of the input's validity object to determine what the error is, and then displays an error message as appropriate.<br>
            
            
             <h2>An Example That Doesn't Use The constraint Validation API</h2>
            <h2>Test Your Skills</h2>
            <h2>In This Module</h2>
            
            <h2>Advanced Topice</h2>
                    <h4>How To Build Custom Form Controls</h4>
                    <h4>Sending Forms Trhough JS</h4>
                    <h4>Property Compatibility Table For Form Widgets</h4>
          </section>


        <section id="transform_transitions">
            <h1>Chapter: Using Fetch</h1>(Examples:wk10/main.js)
            <ul>
                <li><a href="https://developer.mozilla.org/en-US/docs/Learn/Forms/Form_validation" title="Form-Validation"> Client-Side Form Validation</a></li>
            </ul>
            <h2>Supplying Request Options</h2>
            The <b>Fetch</b> API provides a JavaScript interface for accessing and manipulating parts of the HTTP pipeline, such as requests and responses. It also provides a global fetch() method that provides an easy, logical way to fetch 
            resources asynchronously across the network. The fetch specification differs from jQuery.ajax() in three main ways:<br>

              * The Promise returned from fetch() <b>won’t reject on HTTP error status</b> even if the response is an HTTP 404 or 500. Instead, it will resolve normally (with ok status set to false), and it will only reject on network failure or if 
                anything prevented the request from completing.<br>
              * fetch() <s>won't</s> <b>can receive cross-site cookies;</b> you can’t can establish a cross site session using fetch. <s>Set-Cookie</s> headers from other sites are silently ignored.<br>
              * fetch <b>won’t send cookies,</b> unless you set the credentials init option. (Since Aug 25, 2017. The spec changed the default credentials policy to same-origin. Firefox changed since 61.0b13.)<br>
              Fetch requests are controlled by the connect-src directive of Content Security Policy rather than the directive of the resources it's retrieving.<br>
            
            <h2>Supplying Request Options</h2>
            The fetch() method can optionally accept a second parameter, an init object that allows you to control a number of different settings: S
            See fetch() for the full options available, and more details.<br>
              see:  <ul>
                        <li><a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch" title="Fetch Scope">Fetch Syntax & Parameters</a></li>
                    </ul><br>
                    1. fetch syntax<br>
                    2. resource<br>
                    3. init<br>
                      ~ method<br>
                      ~ headers<br>
                      ~ body<br>
                      ~ mode<br>                      
                    4. credentials<br>
                    5. cache<br>
                    6. redirect<br>
                    7. referrer<br>
                    8. referrerPolicy<br>
                    9. integrity<br>
                    10. keepalive<br>
                    11. signal<br>
                    12. promise<br>
                    13. abortError<br>
                    14. typeError<br>

                    The fetch() method can optionally accept a second parameter, an init object that allows you to control a number of different settings. <b>Note</b> that mode: "no-cors" 
                    only allows a limited set of headers in the request:<br>

                      Accept<br>
                      Accept-Language<br>
                      Content-Language<br>
                      Content-Type with a value of application/x-www-form-urlencoded, multipart/form-data, or text/plain<br>
            

            <h2>Sending A Request With Credentials Inclued</h2>
            To cause browsers to send a request with credentials included, even for a cross-origin call, add credentials: 'include' to the init object you pass to the fetch() method.<br>
            <b>Note:</b> Access-Control-Allow-Origin is prohibited from using a wildcard for requests with credentials: 'include'. In such cases, the exact origin must be provided; even if you 
            are using a CORS unblocker.<br>
            extension, the requests will still fail. If you only want to send credentials if the request URL is on the same origin as the calling script, add credentials: 'same-origin'. You can 
            also omit a browser's credentials<br>                        
            
            <h2>Uploading JSON Data</h2>
            See example in wk10/main.js

            <h2>Uploading A File</h2>
            See example in wk10/main.js

            <h2>Uploading Multilple Files</h2>
            See example in wk10/main.js

            <h2>Processing A Text File Line By Line</h2>
            The chunks that are read from a response are not broken neatly at line boundaries and are Uint8Arrays, not strings. If you want to fetch a text file and process it line by line, it is 
            up to you to handle these complications.<br>

            <h2>Checking That The Fetch Was Sucessful</h2>
            A fetch() promise will reject with a TypeError when a network error is encountered or CORS is misconfigured on the server-side, although this usually means permission issues or similar 
            — a 404 does not constitute a network error. An accurate check for a successful fetch() would include checking that the promise resolved, then checking that the Response.ok property has
            a value of true.<br>

            <h2>Supplying Your Own REquest Object</h2>
            Instead of passing a path to the resource you want to request into the fetch() call, you can create a request object using the Request() constructor, and pass that in as a fetch() method 
            argument. Request() accepts exactly the same parameters as the fetch() method. You can even pass in an existing request object to create a copy of it. Making a copy like this allows you 
            to make use of the request/response again while varying the init options if desired. The copy must be made before the body is read, and reading the body in the copy will also mark it as 
            read in the original request.<br>

            <b>Note:</b>  There is also a clone() method that creates a copy. Both methods of creating a copy will fail if the body of the original request or response has already been read, but 
            reading the body of a cloned response or request will not cause it to be marked as read in the original.<br>
            
            
            <h2>Headers</h2>
            The Headers interface allows you to create your own headers object via the Headers() constructor. A headers object is a simple multi-map of names to values. All of the Headers methods throw a 
            TypeError if a header name is used that is not a valid HTTP Header name. The mutation operations will throw a TypeError if there is an immutable guard (see below). Otherwise, they fail silently.
            A good use case for headers is checking whether the content type is correct before you process it further. <br>

            <h2>Guard</h2>
            eaders objects have a guard property. This is not exposed to the Web, but it affects which mutation operations are allowed on the headers object.<br>

            Possible guard values are:<br>
            none: default.
              * request: guard for a headers object obtained from a request (Request.headers).<br>
              * request-no-cors: guard for a headers object obtained from a request created with Request.mode no-cors.<br>
              * response: guard for a Headers obtained from a response (Response.headers).<br>
              * immutable: Mostly used for ServiceWorkers; renders a headers object read-only.<br>
              
              <b>Note:</b> You may not append or set a request guarded Headers’ Content-Length header. Similarly, inserting Set-Cookie into a response header is not allowed: ServiceWorkers are not allowed
              to set cookies via synthesized responses.<br>

            <h2>Response Objects</h2>
            <b>Response</b> instances are returned when fetch() promises are resolved.<br>

            The most common response properties you'll use are:<br>
            
            Response.status — An integer (default value 200) containing the response status code.<br>
            Response.statusText — A string (default value "OK"), which corresponds to the HTTP status code message.<br>
            Response.ok — seen in use above, this is a shorthand for checking that status is in the range 200-299 inclusive. This returns a Boolean.<br>

            They can also be created programmatically via JavaScript, but this is only really useful in ServiceWorkers, when you are providing a custom response to a received request using a respondWith() method.
            The Response() constructor takes two optional arguments — a body for the response, and an init object (similar to the one that Request() accepts.)<br>

            <b>Note:</b>The static method error() simply returns an error response. Similarly, redirect() returns a response resulting in a redirect to a specified URL. These are also only relevant to Service Workers.


            <h2>Body</h2>


            <h2>Feature Dection</h2>


            <h2>Ployfill</h2>
            <h2>Specifications</h2>
            <h2>Browser Compatibility</h2>



        </section>
    </main><br><br>
    <hr class="line1">
    <hr class="line2">
    <hr class="line3">

    <footer class="footer">
        <p class="footer_ph">
            &copy; 2020 | Portfolio | WDD-330 | Instructor: Brother Chad Eddington
        </p>
        <ul id="footer">
            <li><a href="https://www.w3schools.com/js/default.asp" title="W3schools JS"
                    style="color:#6600cc">W3schools/javascript</a></li>
            <li><a href="https://courses.wesbos.com/account/access/5eb152a29edbdf36381221ae/view/194129962"
                    title="JavaScript 30" style="color:#6600cc">JAVASCRIPT 30</a></li>
            <li><a href="https://exploringjs.com/es6/index.html#toc_ch_overviews" title="Exploring ES6"
                    style="color:#6600cc">Exploring ES6</a></li>
            <li><a href="https://www.youtube.com/watch?v=Wy9q22isx3U&list=PLcXgYNNKu8p5oY9FkPSLAAO5evUA-V7zg&index=9&ab_channel=TraversyMedia"
                    title="Vue JS Crash Course" style="color:#6600cc"> JS Crash Course</a></li>
            <li><a href="https://www.sitepoint.com/premium/books/javascript-novice-to-ninja-2nd-edition/read/6/k01nwu9d"
                    title="Sitepoint" style="color:#6600cc">Javascript: Novice to Ninja</a></li>
        </ul>
    </footer>
    <script src="scripts/main.js"></script>
</body>

</html>